name: Note Workflow

on:
  workflow_dispatch:
    inputs:
      theme:
        description: '記事テーマ'
        required: true
        type: string
      target:
        description: '想定読者（ペルソナ）'
        required: true
        type: string
      message:
        description: '読者に伝えたい核メッセージ'
        required: true
        type: string
      cta:
        description: '読後のアクション（CTA）'
        required: true
        type: string
      tags:
        description: 'カンマ区切りタグ（任意）'
        required: false
        default: ''
        type: string
      is_public:
        description: '公開(true)/下書き(false)'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      dry_run:
        description: '投稿をスキップ（生成のみ）'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

permissions:
  contents: read

env:
  TZ: Asia/Tokyo

jobs:
  research:
    name: Research (CCSDK WebSearch/WebFetch)
    runs-on: ubuntu-latest
    env:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      THEME: ${{ github.event.inputs.theme }}
      TARGET: ${{ github.event.inputs.target }}
    outputs:
      research_b64: ${{ steps.collect.outputs.research_b64 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Claude Code SDK
        run: |
          npm init -y
          npm i @anthropic-ai/claude-code

      - name: Research with Claude Code SDK
        run: |
          cat > research.mjs <<'EOF'
          import { query } from '@anthropic-ai/claude-code';
          import fs from 'fs';
          const theme = process.env.THEME || '';
          const target = process.env.TARGET || '';
          const today = new Date().toISOString().slice(0,10);
          const artifactsDir = '.note-artifacts';
          fs.mkdirSync(artifactsDir, { recursive: true });
          const sys = [
            'あなたは最新情報の収集と要約に特化した超一流のリサーチャーです。',
            '事実ベース・一次情報優先・本文内にMarkdownリンクで出典を埋め込むこと。',
            '十分な分量（目安: 2,000語以上）。各節で出典を本文に埋め込む。',
            'WebSearch と WebFetch を必ず使用し、一次情報（公的機関・規格・論文・公式）を優先する。',
          ].join('\n');
          const userPrompt = `以下のテーマとターゲットに対する最終版のリサーチレポートを作成してください。\n【重要】途中経過や確認質問は一切せず、最終レポートのみを返してください。不明点がある場合は「前提と仮定」セクションで簡潔に仮定を明記してから続行してください。事実ベースで一次情報を最優先し、本文にMarkdownリンクで出典を埋め込んでください。\n---\nテーマ: ${theme}\nターゲット: ${target}\n現在日付: ${today}`;
          const messages = [];
          for await (const msg of query({
            prompt: userPrompt,
            options: {
              customSystemPrompt: sys,
              allowedTools: ['WebSearch','WebFetch'],
              permissionMode: 'acceptEdits',
            },
          })) { messages.push(msg); }
          const assistantTexts = messages.filter(m=>m.type==='assistant').map(m=>{
            const c=m.message?.content; if(Array.isArray(c)){return c.filter(b=>b?.type==='text').map(b=>b.text).join('\n');} return '';
          }).filter(Boolean).join('\n\n');
          fs.writeFileSync(`${artifactsDir}/research.md`, assistantTexts || '');
          try { fs.writeFileSync(`${artifactsDir}/research_trace.json`, JSON.stringify(messages, null, 2)); } catch {}
          EOF
          node research.mjs

      - name: Collect research
        id: collect
        run: |
          b64=$(base64 -w 0 .note-artifacts/research.md 2>/dev/null || base64 .note-artifacts/research.md)
          echo "research_b64<<EOF" >> $GITHUB_OUTPUT
          echo "$b64" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload research artifacts
        uses: actions/upload-artifact@v4
        with:
          name: research-artifacts
          path: |
            .note-artifacts/research.md
            .note-artifacts/research_trace.json

  write:
    name: Write (Claude Sonnet 4.0)
    needs: research
    runs-on: ubuntu-latest
    env:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      THEME: ${{ github.event.inputs.theme }}
      TARGET: ${{ github.event.inputs.target }}
      MESSAGE: ${{ github.event.inputs.message }}
      CTA: ${{ github.event.inputs.cta }}
      INPUT_TAGS: ${{ github.event.inputs.tags }}
    outputs:
      title: ${{ steps.collect.outputs.title }}
      draft_json_b64: ${{ steps.collect.outputs.draft_json_b64 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install AI SDK
        run: |
          npm init -y
          npm i ai @ai-sdk/anthropic

      - name: Restore research
        env:
          RESEARCH_B64: ${{ needs.research.outputs.research_b64 }}
        run: |
          mkdir -p .note-artifacts
          echo "$RESEARCH_B64" | base64 -d > .note-artifacts/research.md || echo "$RESEARCH_B64" | base64 --decode > .note-artifacts/research.md

      - name: Generate draft (title/body/tags)
        run: |
          cat > write.mjs <<'EOF'
          import { generateText } from 'ai';
          import { anthropic } from '@ai-sdk/anthropic';
          import fs from 'fs';
          const theme=process.env.THEME||''; const target=process.env.TARGET||''; const message=process.env.MESSAGE||''; const cta=process.env.CTA||'';
          const inputTags=(process.env.INPUT_TAGS||'').split(',').map(s=>s.trim()).filter(Boolean);
          const researchReport=fs.readFileSync('.note-artifacts/research.md','utf8');
          const modelName='claude-sonnet-4-5-20250929';
          function extractJsonFlexible(raw){const t=(raw||'').trim().replace(/\u200B/g,'');try{return JSON.parse(t);}catch{}const m=t.match(/```[a-zA-Z]*\s*([\s\S]*?)\s*```/);if(m&&m[1]){try{return JSON.parse(m[1].trim());}catch{}}const f=t.indexOf('{'),l=t.lastIndexOf('}');if(f!==-1&&l!==-1&&l>f){const c=t.slice(f,l+1);try{return JSON.parse(c);}catch{}}return null;}
          async function repairJson(raw){const sys='入力から {"title":string,"draftBody":string,"tags":string[]} のJSONのみ返答。';const {text}=await generateText({model:anthropic(modelName),system:sys,prompt:String(raw),temperature:0,maxTokens:8000});return extractJsonFlexible(text||'');}
          function sanitizeTitle(t){
            let s=String(t||'').trim();
            // フェンスや見出し、引用符を除去
            s=s.replace(/^```[a-zA-Z0-9_-]*\s*$/,'').replace(/^```$/,'');
            s=s.replace(/^#+\s*/,'');
            s=s.replace(/^"+|"+$/g,'').replace(/^'+|'+$/g,'');
            s=s.replace(/^`+|`+$/g,'');
            s=s.replace(/^json$/i,'').trim();
            if(!s) s='タイトル（自動生成）';
            return s;
          }
          function deriveTitleFromText(text){
            const lines=(text||'').split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
            const firstReal=lines.find(l=>!/^```/.test(l))||lines[0]||'';
            return sanitizeTitle(firstReal);
          }
          const sysWrite='note.com向け長文記事の生成。JSON {title,draftBody,tags[]} で返答。draftBodyは6000〜9000文字を目安に十分な分量で、章ごとに小見出しと箇条書きを適切に含めること。';
          const prompt=[`{テーマ}: ${theme}`,`{ペルソナ}: ${target}`,`{リサーチ内容}: ${researchReport}`,`{伝えたいこと}: ${message}`,`{読後のアクション}: ${cta}`].join('\n');
          const {text}=await generateText({model:anthropic(modelName),system:sysWrite,prompt,temperature:0.7,maxTokens:30000});
          let obj=extractJsonFlexible(text||'')||await repairJson(text||'');
          let title, draftBody, tags; if(obj){title=sanitizeTitle(obj.title); draftBody=String(obj.draftBody||'').trim(); tags=Array.isArray(obj.tags)?obj.tags.map(String):[]}
          if(!title||!draftBody){ title=deriveTitleFromText(text||''); const lines=(text||'').split(/\r?\n/); draftBody=lines.slice(1).join('\n').trim()||(text||''); tags=[]}
          if(inputTags.length){tags=Array.from(new Set([...(tags||[]),...inputTags]));}
          fs.writeFileSync('.note-artifacts/draft.json',JSON.stringify({title,draftBody,tags},null,2));
          EOF
          node write.mjs

      - name: Collect draft
        id: collect
        run: |
          title=$(node -e "console.log(JSON.parse(require('fs').readFileSync('.note-artifacts/draft.json','utf8')).title)")
          b64=$(base64 -w 0 .note-artifacts/draft.json 2>/dev/null || base64 .note-artifacts/draft.json)
          echo "title<<EOF" >> $GITHUB_OUTPUT
          echo "$title" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "draft_json_b64<<EOF" >> $GITHUB_OUTPUT
          echo "$b64" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload draft artifact
        uses: actions/upload-artifact@v4
        with:
          name: draft-artifact
          path: .note-artifacts/draft.json

  post:
    name: Post to note.com (Playwright)
    needs: write
    if: ${{ github.event.inputs.dry_run != 'true' }}
    runs-on: ubuntu-latest
    env:
      IS_PUBLIC: ${{ github.event.inputs.is_public }}
      STATE_JSON: ${{ secrets.NOTE_STORAGE_STATE_JSON }}
      START_URL: https://editor.note.com/new
    outputs:
      final_url: ${{ steps.publish.outputs.published_url || steps.publish.outputs.draft_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Playwright
        run: |
          npm init -y
          npm i playwright
          npx playwright install --with-deps chromium | cat

      - name: Prepare storageState
        id: state
        run: |
          test -n "$STATE_JSON" || (echo "ERROR: NOTE_STORAGE_STATE_JSON secret is not set" && exit 1)
          mkdir -p "$RUNNER_TEMP"
          echo "$STATE_JSON" > "$RUNNER_TEMP/note-state.json"
          echo "STATE_PATH=$RUNNER_TEMP/note-state.json" >> $GITHUB_OUTPUT

      - name: Ensure jq (post)
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

      - name: Restore draft
        id: draft
        env:
          DRAFT_B64: ${{ needs.write.outputs.draft_json_b64 }}
        run: |
          test -n "$DRAFT_B64" || { echo "draft_json_b64 output is empty"; exit 1; }
          echo "$DRAFT_B64" | base64 -d > draft.json || echo "$DRAFT_B64" | base64 --decode > draft.json
          echo "TITLE=$(jq -r .title draft.json)" >> $GITHUB_OUTPUT
          echo "TAGS=$(jq -r '.tags | join(", ")' draft.json)" >> $GITHUB_OUTPUT

      - name: Publish via Playwright (draft or public)
        id: publish
        env:
          TITLE: ${{ steps.draft.outputs.TITLE }}
          TAGS: ${{ steps.draft.outputs.TAGS }}
          STATE_PATH: ${{ steps.state.outputs.STATE_PATH }}
        run: |
          cat > post.mjs <<'EOF'
          import { chromium } from 'playwright';
          import fs from 'fs';
          import os from 'os';
          import path from 'path';

          function nowStr(){ 
            const d=new Date(); 
            const z=n=>String(n).padStart(2,'0'); 
            return `${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())}_${z(d.getHours())}-${z(d.getMinutes())}-${z(d.getSeconds())}`; 
          }

          const STATE_PATH=process.env.STATE_PATH;
          const START_URL=process.env.START_URL||'https://editor.note.com/new';
          const rawTitle=process.env.TITLE||'';
          const TAGS=process.env.TAGS||'';
          const IS_PUBLIC=String(process.env.IS_PUBLIC||'false')==='true';

          // draft.jsonを読み込み
          let articleData;
          try {
            if (fs.existsSync('draft.json')) {
              articleData = JSON.parse(fs.readFileSync('draft.json','utf8'));
              console.log('✅ draft.jsonから記事データを読み込み完了');
            } else {
              console.error('❌ draft.json が見つかりません');
              console.log('📋 現在のディレクトリ内容:');
              const files = fs.readdirSync('.');
              files.forEach(file => console.log(`  - ${file}`));
              process.exit(1);
            }
          } catch (error) {
            console.error('❌ draft.json読み込みエラー:', error.message);
            process.exit(1);
          }

          const rawBody = String(articleData.draftBody || articleData.body || '');

          function sanitizeTitle(t){
            let s=String(t||'').trim();
            s=s.replace(/^```[a-zA-Z0-9_-]*\s*$/,'').replace(/^```$/,'');
            s=s.replace(/^#+\s*/,'');
            s=s.replace(/^"+|"+$/g,'').replace(/^'+|'+$/g,'');
            s=s.replace(/^`+|`+$/g,'');
            s=s.replace(/^json$/i,'').trim();
            if (/^[\{\}\[\]\(\)\s]*$/.test(s)) s='';
            if(!s) s='タイトル（自動生成）';
            return s;
          }

          function processTextContent(text) {
            return String(text||'')
              .replace(/\*\*(.*?)\*\*/g, '$1')
              .replace(/\*(.*?)\*/g, '$1')
              .replace(/`(.*?)`/g, '$1')
              .replace(/#{1,6}\s+/g, '')
              .replace(/^\s*[-*+]\s+/gm, '• ')
              .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
              .trim();
          }

          let TITLE = sanitizeTitle(rawTitle || articleData.title || '');
          let processedBody = processTextContent(rawBody);

          if(!TITLE || TITLE==='タイトル（自動生成）'){
            const lines = processedBody.split('\n');
            for(const line of lines) {
              const clean = line.trim();
              if(clean && clean.length > 0) {
                TITLE = sanitizeTitle(clean);
                break;
              }
            }
          }

          console.log(`🔍 記事情報:`);
          console.log(`  - タイトル: "${TITLE}"`);
          console.log(`  - 本文: ${processedBody.length}文字`);
          console.log(`  - タグ: ${TAGS || 'なし'}`);
          console.log(`  - 公開設定: ${IS_PUBLIC ? '公開' : '下書き'}`);

          if(!fs.existsSync(STATE_PATH)){ 
            console.error('❌ storageState not found:', STATE_PATH); 
            console.log('💡 NOTE_STORAGE_STATE_JSON シークレットが正しく設定されているか確認してください');
            process.exit(1); 
          }

          const ssDir=path.join(os.tmpdir(),'note-screenshots'); 
          fs.mkdirSync(ssDir,{recursive:true}); 

          let browser, context, page;
          try{
            browser = await chromium.launch({ headless: true, args: ['--lang=ja-JP'] });
            context = await browser.newContext({ storageState: STATE_PATH, locale: 'ja-JP' });
            page = await context.newPage();
            page.setDefaultTimeout(180000);

            // デバッグ用ネットワーク監視
            page.on('response', response => {
              if (response.url().includes('/api/')) {
                console.log(`🔍 API Response: ${response.status()} ${response.url()}`);
              }
            });

            await page.goto(START_URL, { waitUntil: 'domcontentloaded' });
            console.log(`🔍 ページ読み込み完了: ${page.url()}`);

            // タイトル入力要素を探索
            const titleSelectors = [
              'textarea[placeholder*="タイトル"]',
              'input[placeholder*="タイトル"]', 
              'textarea[data-testid*="title"]',
              'input[data-testid*="title"]',
              '[contenteditable][data-placeholder*="タイトル"]'
            ];
            
            let titleElement = null;
            for (const selector of titleSelectors) {
              try {
                await page.waitForSelector(selector, { timeout: 5000 });
                titleElement = page.locator(selector).first();
                console.log(`🔍 タイトル要素発見: ${selector}`);
                break;
              } catch {
                console.log(`🔍 タイトル要素なし: ${selector}`);
              }
            }
            
            if (!titleElement) {
              console.log(`🔍 エラー: タイトル入力要素が見つからない`);
              await page.screenshot({ path: `${ssDir}/error-no-title-${nowStr()}.png`, fullPage: true });
              process.exit(1);
            }

            // デバッグ用スクリーンショット
            await page.screenshot({ path: `${ssDir}/debug-1-initial-${nowStr()}.png`, fullPage: true });

            // タイトル入力
            await titleElement.fill(TITLE);
            console.log(`🔍 タイトル入力完了`);
            await page.screenshot({ path: `${ssDir}/debug-2-after-title-${nowStr()}.png`, fullPage: true });

            // 本文入力要素を探索
            const bodySelectors = [
              'div[contenteditable="true"][role="textbox"]',
              'div[contenteditable="true"][data-testid*="editor"]', 
              'div[contenteditable="true"]',
              'textarea[data-testid*="body"]',
              'textarea[placeholder*="本文"]'
            ];
            
            let bodyElement = null;
            for (const selector of bodySelectors) {
              const count = await page.locator(selector).count();
              if (count > 0) {
                bodyElement = page.locator(selector).first();
                console.log(`🔍 本文要素発見: ${selector} (${count}個)`);
                break;
              }
            }
            
            if (!bodyElement) {
              console.log(`🔍 エラー: 本文入力要素が見つからない`);
              await page.screenshot({ path: `${ssDir}/error-no-body-${nowStr()}.png`, fullPage: true });
              process.exit(1);
            }

            // 本文入力（シンプルなテキスト入力）
            await bodyElement.waitFor({ state: 'visible' });
            await bodyElement.click();
            await page.keyboard.type(processedBody, { delay: 10 });
            console.log(`🔍 本文入力完了`);
            await page.screenshot({ path: `${ssDir}/debug-3-after-body-${nowStr()}.png`, fullPage: true });

            if(!IS_PUBLIC){
              // 下書き保存ボタンを探索
              const saveSelectors = [
                'button:has-text("下書き保存")',
                'button:has-text("下書きに保存")',
                'button:has-text("保存")',
                '[aria-label*="下書き保存"]',
                '[aria-label*="保存"]',
                'button[data-testid*="draft"]',
                'button[data-testid*="save"]',
                '[role="button"]:has-text("下書き")',
                '[role="button"]:has-text("保存")'
              ];
              
              await page.screenshot({ path: `${ssDir}/debug-4-searching-save-${nowStr()}.png`, fullPage: true });
              
              let saveButton = null;
              console.log(`🔍 下書き保存ボタンを探索中...`);
              
              for (const selector of saveSelectors) {
                const count = await page.locator(selector).count();
                console.log(`🔍 "${selector}": ${count}個`);
                if (count > 0) {
                  saveButton = page.locator(selector).first();
                  const text = await saveButton.textContent();
                  console.log(`🔍 発見！ボタンテキスト: "${text}"`);
                  break;
                }
              }
              
              // 全ボタンを表示（デバッグ用）
              const allButtons = await page.locator('button').all();
              console.log(`🔍 全ボタン (${allButtons.length}個)：`);
              for (let i = 0; i < Math.min(10, allButtons.length); i++) {
                const text = await allButtons[i].textContent();
                const ariaLabel = await allButtons[i].getAttribute('aria-label');
                console.log(`  ${i+1}. "${text}" [${ariaLabel}]`);
              }
              
              if (!saveButton) {
                console.log(`🔍 エラー: 下書き保存ボタンが見つからない`);
                await page.screenshot({ path: `${ssDir}/error-no-save-button-${nowStr()}.png`, fullPage: true });
                process.exit(1);
              }
              
              try {
                await saveButton.waitFor({ state: 'visible', timeout: 10000 });
                const isVisible = await saveButton.isVisible();
                const isEnabled = await saveButton.isEnabled();
                console.log(`🔍 下書き保存ボタン状態: 表示=${isVisible}, 有効=${isEnabled}`);
                
                if(isVisible && isEnabled) { 
                  console.log(`🔍 下書き保存ボタンをクリック`);
                  await saveButton.click(); 
                  await page.screenshot({ path: `${ssDir}/debug-5-after-save-${nowStr()}.png`, fullPage: true });
                  
                  // 保存完了待機
                  await page.waitForTimeout(3000);
                  console.log(`🔍 保存処理完了`);
                } else {
                  console.log(`🔍 エラー: 下書き保存ボタンが使用不可`);
                }
              } catch (error) {
                console.log(`🔍 エラー: 保存処理中に問題発生 - ${error.message}`);
              }
              
              await page.screenshot({ path: `${ssDir}/debug-6-final-${nowStr()}.png`, fullPage: true });
              console.log(`🔍 最終URL: ${page.url()}`);
              console.log('DRAFT_URL=' + page.url());
              process.exit(0);
            }

            // 公開処理（省略）

          } finally {
            try{ await page?.close(); }catch{}
            try{ await context?.close(); }catch{}
            try{ await browser?.close(); }catch{}
          }
          EOF
          node post.mjs | tee post.log
          url=$(grep '^PUBLISHED_URL=' post.log | tail -n1 | cut -d'=' -f2-)
          draft=$(grep '^DRAFT_URL=' post.log | tail -n1 | cut -d'=' -f2-)
          shot=$(grep '^SCREENSHOT=' post.log | tail -n1 | cut -d'=' -f2-)
          if [ -n "$url" ]; then echo "published_url=$url" >> $GITHUB_OUTPUT; fi
          if [ -n "$draft" ]; then echo "draft_url=$draft" >> $GITHUB_OUTPUT; fi
          if [ -n "$shot" ]; then echo "screenshot=$shot" >> $GITHUB_OUTPUT; fi

      - name: Upload screenshot (if any)
        if: ${{ steps.publish.outputs.screenshot != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: note-screenshot
          path: ${{ steps.publish.outputs.screenshot }}
