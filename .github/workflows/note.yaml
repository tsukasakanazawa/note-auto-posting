name: Note Workflow

on:
  workflow_dispatch:
    inputs:
      theme:
        description: 'è¨˜äº‹ãƒ†ãƒ¼ãƒ'
        required: true
        type: string
      target:
        description: 'æƒ³å®šèª­è€…ï¼ˆãƒšãƒ«ã‚½ãƒŠï¼‰'
        required: true
        type: string
      message:
        description: 'èª­è€…ã«ä¼ãˆãŸã„æ ¸ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸'
        required: true
        type: string
      cta:
        description: 'èª­å¾Œã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆCTAï¼‰'
        required: true
        type: string
      tags:
        description: 'ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šã‚¿ã‚°ï¼ˆä»»æ„ï¼‰'
        required: false
        default: ''
        type: string
      is_public:
        description: 'å…¬é–‹(true)/ä¸‹æ›¸ã(false)'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      dry_run:
        description: 'æŠ•ç¨¿ã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼ˆç”Ÿæˆã®ã¿ï¼‰'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

permissions:
  contents: read

env:
  TZ: Asia/Tokyo

jobs:
  research:
    name: Research (CCSDK WebSearch/WebFetch)
    runs-on: ubuntu-latest
    env:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      THEME: ${{ github.event.inputs.theme }}
      TARGET: ${{ github.event.inputs.target }}
    outputs:
      research_b64: ${{ steps.collect.outputs.research_b64 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Claude Code SDK
        run: |
          npm init -y
          npm i @anthropic-ai/claude-code

      - name: Research with Claude Code SDK
        run: |
          cat > research.mjs <<'EOF'
          import { query } from '@anthropic-ai/claude-code';
          import fs from 'fs';
          const theme = process.env.THEME || '';
          const target = process.env.TARGET || '';
          const today = new Date().toISOString().slice(0,10);
          const artifactsDir = '.note-artifacts';
          fs.mkdirSync(artifactsDir, { recursive: true });
          const sys = [
            'ã‚ãªãŸã¯æœ€æ–°æƒ…å ±ã®åé›†ã¨è¦ç´„ã«ç‰¹åŒ–ã—ãŸè¶…ä¸€æµã®ãƒªã‚µãƒ¼ãƒãƒ£ãƒ¼ã§ã™ã€‚',
            'äº‹å®Ÿãƒ™ãƒ¼ã‚¹ãƒ»ä¸€æ¬¡æƒ…å ±å„ªå…ˆãƒ»æœ¬æ–‡å†…ã«Markdownãƒªãƒ³ã‚¯ã§å‡ºå…¸ã‚’åŸ‹ã‚è¾¼ã‚€ã“ã¨ã€‚',
            'ååˆ†ãªåˆ†é‡ï¼ˆç›®å®‰: 2,000èªä»¥ä¸Šï¼‰ã€‚å„ç¯€ã§å‡ºå…¸ã‚’æœ¬æ–‡ã«åŸ‹ã‚è¾¼ã‚€ã€‚',
            'WebSearch ã¨ WebFetch ã‚’å¿…ãšä½¿ç”¨ã—ã€ä¸€æ¬¡æƒ…å ±ï¼ˆå…¬çš„æ©Ÿé–¢ãƒ»è¦æ ¼ãƒ»è«–æ–‡ãƒ»å…¬å¼ï¼‰ã‚’å„ªå…ˆã™ã‚‹ã€‚',
          ].join('\n');
          const userPrompt = `ä»¥ä¸‹ã®ãƒ†ãƒ¼ãƒã¨ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«å¯¾ã™ã‚‹æœ€çµ‚ç‰ˆã®ãƒªã‚µãƒ¼ãƒãƒ¬ãƒãƒ¼ãƒˆã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚\nã€é‡è¦ã€‘é€”ä¸­çµŒéã‚„ç¢ºèªè³ªå•ã¯ä¸€åˆ‡ã›ãšã€æœ€çµ‚ãƒ¬ãƒãƒ¼ãƒˆã®ã¿ã‚’è¿”ã—ã¦ãã ã•ã„ã€‚ä¸æ˜ç‚¹ãŒã‚ã‚‹å ´åˆã¯ã€Œå‰æã¨ä»®å®šã€ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ç°¡æ½”ã«ä»®å®šã‚’æ˜è¨˜ã—ã¦ã‹ã‚‰ç¶šè¡Œã—ã¦ãã ã•ã„ã€‚äº‹å®Ÿãƒ™ãƒ¼ã‚¹ã§ä¸€æ¬¡æƒ…å ±ã‚’æœ€å„ªå…ˆã—ã€æœ¬æ–‡ã«Markdownãƒªãƒ³ã‚¯ã§å‡ºå…¸ã‚’åŸ‹ã‚è¾¼ã‚“ã§ãã ã•ã„ã€‚\n---\nãƒ†ãƒ¼ãƒ: ${theme}\nã‚¿ãƒ¼ã‚²ãƒƒãƒˆ: ${target}\nç¾åœ¨æ—¥ä»˜: ${today}`;
          const messages = [];
          for await (const msg of query({
            prompt: userPrompt,
            options: {
              customSystemPrompt: sys,
              allowedTools: ['WebSearch','WebFetch'],
              permissionMode: 'acceptEdits',
            },
          })) { messages.push(msg); }
          const assistantTexts = messages.filter(m=>m.type==='assistant').map(m=>{
            const c=m.message?.content; if(Array.isArray(c)){return c.filter(b=>b?.type==='text').map(b=>b.text).join('\n');} return '';
          }).filter(Boolean).join('\n\n');
          fs.writeFileSync(`${artifactsDir}/research.md`, assistantTexts || '');
          try { fs.writeFileSync(`${artifactsDir}/research_trace.json`, JSON.stringify(messages, null, 2)); } catch {}
          EOF
          node research.mjs

      - name: Collect research
        id: collect
        run: |
          b64=$(base64 -w 0 .note-artifacts/research.md 2>/dev/null || base64 .note-artifacts/research.md)
          echo "research_b64<<EOF" >> $GITHUB_OUTPUT
          echo "$b64" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload research artifacts
        uses: actions/upload-artifact@v4
        with:
          name: research-artifacts
          path: |
            .note-artifacts/research.md
            .note-artifacts/research_trace.json

  write:
    name: Write (Claude Sonnet 4.0)
    needs: research
    runs-on: ubuntu-latest
    env:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      THEME: ${{ github.event.inputs.theme }}
      TARGET: ${{ github.event.inputs.target }}
      MESSAGE: ${{ github.event.inputs.message }}
      CTA: ${{ github.event.inputs.cta }}
      INPUT_TAGS: ${{ github.event.inputs.tags }}
    outputs:
      title: ${{ steps.collect.outputs.title }}
      draft_json_b64: ${{ steps.collect.outputs.draft_json_b64 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install AI SDK
        run: |
          npm init -y
          npm i ai @ai-sdk/anthropic

      - name: Restore research
        env:
          RESEARCH_B64: ${{ needs.research.outputs.research_b64 }}
        run: |
          mkdir -p .note-artifacts
          echo "$RESEARCH_B64" | base64 -d > .note-artifacts/research.md || echo "$RESEARCH_B64" | base64 --decode > .note-artifacts/research.md

      - name: Generate draft (title/body/tags)
        run: |
          cat > write.mjs <<'EOF'
          import { generateText } from 'ai';
          import { anthropic } from '@ai-sdk/anthropic';
          import fs from 'fs';
          const theme=process.env.THEME||''; const target=process.env.TARGET||''; const message=process.env.MESSAGE||''; const cta=process.env.CTA||'';
          const inputTags=(process.env.INPUT_TAGS||'').split(',').map(s=>s.trim()).filter(Boolean);
          const researchReport=fs.readFileSync('.note-artifacts/research.md','utf8');
          const modelName='claude-sonnet-4-5-20250929';
          function extractJsonFlexible(raw){const t=(raw||'').trim().replace(/\u200B/g,'');try{return JSON.parse(t);}catch{}const m=t.match(/```[a-zA-Z]*\s*([\s\S]*?)\s*```/);if(m&&m[1]){try{return JSON.parse(m[1].trim());}catch{}}const f=t.indexOf('{'),l=t.lastIndexOf('}');if(f!==-1&&l!==-1&&l>f){const c=t.slice(f,l+1);try{return JSON.parse(c);}catch{}}return null;}
          async function repairJson(raw){const sys='å…¥åŠ›ã‹ã‚‰ {"title":string,"draftBody":string,"tags":string[]} ã®JSONã®ã¿è¿”ç­”ã€‚';const {text}=await generateText({model:anthropic(modelName),system:sys,prompt:String(raw),temperature:0,maxTokens:8000});return extractJsonFlexible(text||'');}
          function sanitizeTitle(t){
            let s=String(t||'').trim();
            // ãƒ•ã‚§ãƒ³ã‚¹ã‚„è¦‹å‡ºã—ã€å¼•ç”¨ç¬¦ã‚’é™¤å»
            s=s.replace(/^```[a-zA-Z0-9_-]*\s*$/,'').replace(/^```$/,'');
            s=s.replace(/^#+\s*/,'');
            s=s.replace(/^"+|"+$/g,'').replace(/^'+|'+$/g,'');
            s=s.replace(/^`+|`+$/g,'');
            s=s.replace(/^json$/i,'').trim();
            if(!s) s='ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆè‡ªå‹•ç”Ÿæˆï¼‰';
            return s;
          }
          function deriveTitleFromText(text){
            const lines=(text||'').split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
            const firstReal=lines.find(l=>!/^```/.test(l))||lines[0]||'';
            return sanitizeTitle(firstReal);
          }
          const sysWrite='note.comå‘ã‘é•·æ–‡è¨˜äº‹ã®ç”Ÿæˆã€‚JSON {title,draftBody,tags[]} ã§è¿”ç­”ã€‚draftBodyã¯6000ã€œ9000æ–‡å­—ã‚’ç›®å®‰ã«ååˆ†ãªåˆ†é‡ã§ã€ç« ã”ã¨ã«å°è¦‹å‡ºã—ã¨ç®‡æ¡æ›¸ãã‚’é©åˆ‡ã«å«ã‚ã‚‹ã“ã¨ã€‚';
          const prompt=[`{ãƒ†ãƒ¼ãƒ}: ${theme}`,`{ãƒšãƒ«ã‚½ãƒŠ}: ${target}`,`{ãƒªã‚µãƒ¼ãƒå†…å®¹}: ${researchReport}`,`{ä¼ãˆãŸã„ã“ã¨}: ${message}`,`{èª­å¾Œã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³}: ${cta}`].join('\n');
          const {text}=await generateText({model:anthropic(modelName),system:sysWrite,prompt,temperature:0.7,maxTokens:30000});
          let obj=extractJsonFlexible(text||'')||await repairJson(text||'');
          let title, draftBody, tags; if(obj){title=sanitizeTitle(obj.title); draftBody=String(obj.draftBody||'').trim(); tags=Array.isArray(obj.tags)?obj.tags.map(String):[]}
          if(!title||!draftBody){ title=deriveTitleFromText(text||''); const lines=(text||'').split(/\r?\n/); draftBody=lines.slice(1).join('\n').trim()||(text||''); tags=[]}
          if(inputTags.length){tags=Array.from(new Set([...(tags||[]),...inputTags]));}
          fs.writeFileSync('.note-artifacts/draft.json',JSON.stringify({title,draftBody,tags},null,2));
          EOF
          node write.mjs

      - name: Collect draft
        id: collect
        run: |
          title=$(node -e "console.log(JSON.parse(require('fs').readFileSync('.note-artifacts/draft.json','utf8')).title)")
          b64=$(base64 -w 0 .note-artifacts/draft.json 2>/dev/null || base64 .note-artifacts/draft.json)
          echo "title<<EOF" >> $GITHUB_OUTPUT
          echo "$title" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "draft_json_b64<<EOF" >> $GITHUB_OUTPUT
          echo "$b64" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload draft artifact
        uses: actions/upload-artifact@v4
        with:
          name: draft-artifact
          path: .note-artifacts/draft.json

  post:
    name: Post to note.com (Playwright)
    needs: write
    if: ${{ github.event.inputs.dry_run != 'true' }}
    runs-on: ubuntu-latest
    env:
      IS_PUBLIC: ${{ github.event.inputs.is_public }}
      STATE_JSON: ${{ secrets.NOTE_STORAGE_STATE_JSON }}
      START_URL: https://editor.note.com/new
    outputs:
      final_url: ${{ steps.publish.outputs.published_url || steps.publish.outputs.draft_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Playwright
        run: |
          npm init -y
          npm i playwright
          npx playwright install --with-deps chromium | cat

      - name: Prepare storageState
        id: state
        run: |
          test -n "$STATE_JSON" || (echo "ERROR: NOTE_STORAGE_STATE_JSON secret is not set" && exit 1)
          mkdir -p "$RUNNER_TEMP"
          echo "$STATE_JSON" > "$RUNNER_TEMP/note-state.json"
          echo "STATE_PATH=$RUNNER_TEMP/note-state.json" >> $GITHUB_OUTPUT

      - name: Ensure jq (post)
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

      - name: Restore draft
        id: draft
        env:
          DRAFT_B64: ${{ needs.write.outputs.draft_json_b64 }}
        run: |
          test -n "$DRAFT_B64" || { echo "draft_json_b64 output is empty"; exit 1; }
          echo "$DRAFT_B64" | base64 -d > draft.json || echo "$DRAFT_B64" | base64 --decode > draft.json
          echo "TITLE=$(jq -r .title draft.json)" >> $GITHUB_OUTPUT
          echo "TAGS=$(jq -r '.tags | join(", ")' draft.json)" >> $GITHUB_OUTPUT

      - name: Publish via Playwright (draft or public)
        id: publish
        env:
          TITLE: ${{ steps.draft.outputs.TITLE }}
          TAGS: ${{ steps.draft.outputs.TAGS }}
          STATE_PATH: ${{ steps.state.outputs.STATE_PATH }}
        run: |
          cat > post.mjs <<'EOF'
          import { chromium } from 'playwright';
          import fs from 'fs';
          import os from 'os';
          import path from 'path';

          function nowStr(){ 
            const d=new Date(); 
            const z=n=>String(n).padStart(2,'0'); 
            return `${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())}_${z(d.getHours())}-${z(d.getMinutes())}-${z(d.getSeconds())}`; 
          }

          const STATE_PATH=process.env.STATE_PATH;
          const START_URL=process.env.START_URL||'https://editor.note.com/new';
          const rawTitle=process.env.TITLE||'';
          const TAGS=process.env.TAGS||'';
          const IS_PUBLIC=String(process.env.IS_PUBLIC||'false')==='true';

          // draft.jsonã‚’èª­ã¿è¾¼ã¿
          let articleData;
          try {
            if (fs.existsSync('draft.json')) {
              articleData = JSON.parse(fs.readFileSync('draft.json','utf8'));
              console.log('âœ… draft.jsonã‹ã‚‰è¨˜äº‹ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿å®Œäº†');
            } else {
              console.error('âŒ draft.json ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
              console.log('ğŸ“‹ ç¾åœ¨ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå†…å®¹:');
              const files = fs.readdirSync('.');
              files.forEach(file => console.log(`  - ${file}`));
              process.exit(1);
            }
          } catch (error) {
            console.error('âŒ draft.jsonèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error.message);
            process.exit(1);
          }

          const rawBody = String(articleData.draftBody || articleData.body || '');

          function sanitizeTitle(t){
            let s=String(t||'').trim();
            s=s.replace(/^```[a-zA-Z0-9_-]*\s*$/,'').replace(/^```$/,'');
            s=s.replace(/^#+\s*/,'');
            s=s.replace(/^"+|"+$/g,'').replace(/^'+|'+$/g,'');
            s=s.replace(/^`+|`+$/g,'');
            s=s.replace(/^json$/i,'').trim();
            if (/^[\{\}\[\]\(\)\s]*$/.test(s)) s='';
            if(!s) s='ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆè‡ªå‹•ç”Ÿæˆï¼‰';
            return s;
          }

          function processTextContent(text) {
            return String(text||'')
              .replace(/\*\*(.*?)\*\*/g, '$1')
              .replace(/\*(.*?)\*/g, '$1')
              .replace(/`(.*?)`/g, '$1')
              .replace(/#{1,6}\s+/g, '')
              .replace(/^\s*[-*+]\s+/gm, 'â€¢ ')
              .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
              .trim();
          }

          let TITLE = sanitizeTitle(rawTitle || articleData.title || '');
          let processedBody = processTextContent(rawBody);

          if(!TITLE || TITLE==='ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆè‡ªå‹•ç”Ÿæˆï¼‰'){
            const lines = processedBody.split('\n');
            for(const line of lines) {
              const clean = line.trim();
              if(clean && clean.length > 0) {
                TITLE = sanitizeTitle(clean);
                break;
              }
            }
          }

          console.log(`ğŸ” è¨˜äº‹æƒ…å ±:`);
          console.log(`  - ã‚¿ã‚¤ãƒˆãƒ«: "${TITLE}"`);
          console.log(`  - æœ¬æ–‡: ${processedBody.length}æ–‡å­—`);
          console.log(`  - ã‚¿ã‚°: ${TAGS || 'ãªã—'}`);
          console.log(`  - å…¬é–‹è¨­å®š: ${IS_PUBLIC ? 'å…¬é–‹' : 'ä¸‹æ›¸ã'}`);

          if(!fs.existsSync(STATE_PATH)){ 
            console.error('âŒ storageState not found:', STATE_PATH); 
            console.log('ğŸ’¡ NOTE_STORAGE_STATE_JSON ã‚·ãƒ¼ã‚¯ãƒ¬ãƒƒãƒˆãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„');
            process.exit(1); 
          }

          const ssDir=path.join(os.tmpdir(),'note-screenshots'); 
          fs.mkdirSync(ssDir,{recursive:true}); 

          let browser, context, page;
          try{
            browser = await chromium.launch({ headless: true, args: ['--lang=ja-JP'] });
            context = await browser.newContext({ storageState: STATE_PATH, locale: 'ja-JP' });
            page = await context.newPage();
            page.setDefaultTimeout(180000);

            // ãƒ‡ãƒãƒƒã‚°ç”¨ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç›£è¦–
            page.on('response', response => {
              if (response.url().includes('/api/')) {
                console.log(`ğŸ” API Response: ${response.status()} ${response.url()}`);
              }
            });

            await page.goto(START_URL, { waitUntil: 'domcontentloaded' });
            console.log(`ğŸ” ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿å®Œäº†: ${page.url()}`);

            // ã‚¿ã‚¤ãƒˆãƒ«å…¥åŠ›è¦ç´ ã‚’æ¢ç´¢
            const titleSelectors = [
              'textarea[placeholder*="ã‚¿ã‚¤ãƒˆãƒ«"]',
              'input[placeholder*="ã‚¿ã‚¤ãƒˆãƒ«"]', 
              'textarea[data-testid*="title"]',
              'input[data-testid*="title"]',
              '[contenteditable][data-placeholder*="ã‚¿ã‚¤ãƒˆãƒ«"]'
            ];
            
            let titleElement = null;
            for (const selector of titleSelectors) {
              try {
                await page.waitForSelector(selector, { timeout: 5000 });
                titleElement = page.locator(selector).first();
                console.log(`ğŸ” ã‚¿ã‚¤ãƒˆãƒ«è¦ç´ ç™ºè¦‹: ${selector}`);
                break;
              } catch {
                console.log(`ğŸ” ã‚¿ã‚¤ãƒˆãƒ«è¦ç´ ãªã—: ${selector}`);
              }
            }
            
            if (!titleElement) {
              console.log(`ğŸ” ã‚¨ãƒ©ãƒ¼: ã‚¿ã‚¤ãƒˆãƒ«å…¥åŠ›è¦ç´ ãŒè¦‹ã¤ã‹ã‚‰ãªã„`);
              await page.screenshot({ path: `${ssDir}/error-no-title-${nowStr()}.png`, fullPage: true });
              process.exit(1);
            }

            // ãƒ‡ãƒãƒƒã‚°ç”¨ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆ
            await page.screenshot({ path: `${ssDir}/debug-1-initial-${nowStr()}.png`, fullPage: true });

            // ã‚¿ã‚¤ãƒˆãƒ«å…¥åŠ›
            await titleElement.fill(TITLE);
            console.log(`ğŸ” ã‚¿ã‚¤ãƒˆãƒ«å…¥åŠ›å®Œäº†`);
            await page.screenshot({ path: `${ssDir}/debug-2-after-title-${nowStr()}.png`, fullPage: true });

            // æœ¬æ–‡å…¥åŠ›è¦ç´ ã‚’æ¢ç´¢
            const bodySelectors = [
              'div[contenteditable="true"][role="textbox"]',
              'div[contenteditable="true"][data-testid*="editor"]', 
              'div[contenteditable="true"]',
              'textarea[data-testid*="body"]',
              'textarea[placeholder*="æœ¬æ–‡"]'
            ];
            
            let bodyElement = null;
            for (const selector of bodySelectors) {
              const count = await page.locator(selector).count();
              if (count > 0) {
                bodyElement = page.locator(selector).first();
                console.log(`ğŸ” æœ¬æ–‡è¦ç´ ç™ºè¦‹: ${selector} (${count}å€‹)`);
                break;
              }
            }
            
            if (!bodyElement) {
              console.log(`ğŸ” ã‚¨ãƒ©ãƒ¼: æœ¬æ–‡å…¥åŠ›è¦ç´ ãŒè¦‹ã¤ã‹ã‚‰ãªã„`);
              await page.screenshot({ path: `${ssDir}/error-no-body-${nowStr()}.png`, fullPage: true });
              process.exit(1);
            }

            // æœ¬æ–‡å…¥åŠ›ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ãªãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ï¼‰
            await bodyElement.waitFor({ state: 'visible' });
            await bodyElement.click();
            await page.keyboard.type(processedBody, { delay: 10 });
            console.log(`ğŸ” æœ¬æ–‡å…¥åŠ›å®Œäº†`);
            await page.screenshot({ path: `${ssDir}/debug-3-after-body-${nowStr()}.png`, fullPage: true });

            if(!IS_PUBLIC){
              // ä¸‹æ›¸ãä¿å­˜ãƒœã‚¿ãƒ³ã‚’æ¢ç´¢
              const saveSelectors = [
                'button:has-text("ä¸‹æ›¸ãä¿å­˜")',
                'button:has-text("ä¸‹æ›¸ãã«ä¿å­˜")',
                'button:has-text("ä¿å­˜")',
                '[aria-label*="ä¸‹æ›¸ãä¿å­˜"]',
                '[aria-label*="ä¿å­˜"]',
                'button[data-testid*="draft"]',
                'button[data-testid*="save"]',
                '[role="button"]:has-text("ä¸‹æ›¸ã")',
                '[role="button"]:has-text("ä¿å­˜")'
              ];
              
              await page.screenshot({ path: `${ssDir}/debug-4-searching-save-${nowStr()}.png`, fullPage: true });
              
              let saveButton = null;
              console.log(`ğŸ” ä¸‹æ›¸ãä¿å­˜ãƒœã‚¿ãƒ³ã‚’æ¢ç´¢ä¸­...`);
              
              for (const selector of saveSelectors) {
                const count = await page.locator(selector).count();
                console.log(`ğŸ” "${selector}": ${count}å€‹`);
                if (count > 0) {
                  saveButton = page.locator(selector).first();
                  const text = await saveButton.textContent();
                  console.log(`ğŸ” ç™ºè¦‹ï¼ãƒœã‚¿ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ: "${text}"`);
                  break;
                }
              }
              
              // å…¨ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤ºï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
              const allButtons = await page.locator('button').all();
              console.log(`ğŸ” å…¨ãƒœã‚¿ãƒ³ (${allButtons.length}å€‹)ï¼š`);
              for (let i = 0; i < Math.min(10, allButtons.length); i++) {
                const text = await allButtons[i].textContent();
                const ariaLabel = await allButtons[i].getAttribute('aria-label');
                console.log(`  ${i+1}. "${text}" [${ariaLabel}]`);
              }
              
              if (!saveButton) {
                console.log(`ğŸ” ã‚¨ãƒ©ãƒ¼: ä¸‹æ›¸ãä¿å­˜ãƒœã‚¿ãƒ³ãŒè¦‹ã¤ã‹ã‚‰ãªã„`);
                await page.screenshot({ path: `${ssDir}/error-no-save-button-${nowStr()}.png`, fullPage: true });
                process.exit(1);
              }
              
              try {
                await saveButton.waitFor({ state: 'visible', timeout: 10000 });
                const isVisible = await saveButton.isVisible();
                const isEnabled = await saveButton.isEnabled();
                console.log(`ğŸ” ä¸‹æ›¸ãä¿å­˜ãƒœã‚¿ãƒ³çŠ¶æ…‹: è¡¨ç¤º=${isVisible}, æœ‰åŠ¹=${isEnabled}`);
                
                if(isVisible && isEnabled) { 
                  console.log(`ğŸ” ä¸‹æ›¸ãä¿å­˜ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯`);
                  await saveButton.click(); 
                  await page.screenshot({ path: `${ssDir}/debug-5-after-save-${nowStr()}.png`, fullPage: true });
                  
                  // ä¿å­˜å®Œäº†å¾…æ©Ÿ
                  await page.waitForTimeout(3000);
                  console.log(`ğŸ” ä¿å­˜å‡¦ç†å®Œäº†`);
                } else {
                  console.log(`ğŸ” ã‚¨ãƒ©ãƒ¼: ä¸‹æ›¸ãä¿å­˜ãƒœã‚¿ãƒ³ãŒä½¿ç”¨ä¸å¯`);
                }
              } catch (error) {
                console.log(`ğŸ” ã‚¨ãƒ©ãƒ¼: ä¿å­˜å‡¦ç†ä¸­ã«å•é¡Œç™ºç”Ÿ - ${error.message}`);
              }
              
              await page.screenshot({ path: `${ssDir}/debug-6-final-${nowStr()}.png`, fullPage: true });
              console.log(`ğŸ” æœ€çµ‚URL: ${page.url()}`);
              console.log('DRAFT_URL=' + page.url());
              process.exit(0);
            }

            // å…¬é–‹å‡¦ç†ï¼ˆçœç•¥ï¼‰

          } finally {
            try{ await page?.close(); }catch{}
            try{ await context?.close(); }catch{}
            try{ await browser?.close(); }catch{}
          }
          EOF
          node post.mjs | tee post.log
          url=$(grep '^PUBLISHED_URL=' post.log | tail -n1 | cut -d'=' -f2-)
          draft=$(grep '^DRAFT_URL=' post.log | tail -n1 | cut -d'=' -f2-)
          shot=$(grep '^SCREENSHOT=' post.log | tail -n1 | cut -d'=' -f2-)
          if [ -n "$url" ]; then echo "published_url=$url" >> $GITHUB_OUTPUT; fi
          if [ -n "$draft" ]; then echo "draft_url=$draft" >> $GITHUB_OUTPUT; fi
          if [ -n "$shot" ]; then echo "screenshot=$shot" >> $GITHUB_OUTPUT; fi

      - name: Upload screenshot (if any)
        if: ${{ steps.publish.outputs.screenshot != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: note-screenshot
          path: ${{ steps.publish.outputs.screenshot }}
