name: Note Workflow

on:
  workflow_dispatch:
    inputs:
      theme:
        description: '記事テーマ'
        required: true
        type: string
      target:
        description: '想定読者（ペルソナ）'
        required: true
        type: string
      message:
        description: '読者に伝えたい核メッセージ'
        required: true
        type: string
      cta:
        description: '読後のアクション（CTA）'
        required: true
        type: string
      tags:
        description: 'カンマ区切りタグ（任意）'
        required: false
        default: ''
        type: string
      is_public:
        description: '公開(true)/下書き(false)'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      dry_run:
        description: '投稿をスキップ（生成のみ）'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

permissions:
  contents: read

env:
  TZ: Asia/Tokyo

jobs:
  research:
    name: Research (CCSDK WebSearch/WebFetch)
    runs-on: ubuntu-latest
    env:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      THEME: ${{ github.event.inputs.theme }}
      TARGET: ${{ github.event.inputs.target }}
    outputs:
      research_b64: ${{ steps.collect.outputs.research_b64 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Claude Code SDK
        run: |
          npm init -y
          npm i @anthropic-ai/claude-code

      - name: Research with Claude Code SDK
        run: |
          cat > research.mjs <<'EOF'
          import { query } from '@anthropic-ai/claude-code';
          import fs from 'fs';
          const theme = process.env.THEME || '';
          const target = process.env.TARGET || '';
          const today = new Date().toISOString().slice(0,10);
          const artifactsDir = '.note-artifacts';
          fs.mkdirSync(artifactsDir, { recursive: true });
          const sys = [
            'あなたは最新情報の収集と要約に特化した超一流のリサーチャーです。',
            '事実ベース・一次情報優先・本文内にMarkdownリンクで出典を埋め込むこと。',
            '十分な分量（目安: 2,000語以上）。各節で出典を本文に埋め込む。',
            'WebSearch と WebFetch を必ず使用し、一次情報（公的機関・規格・論文・公式）を優先する。',
          ].join('\n');
          const userPrompt = `以下のテーマとターゲットに対する最終版のリサーチレポートを作成してください。\n【重要】途中経過や確認質問は一切せず、最終レポートのみを返してください。不明点がある場合は「前提と仮定」セクションで簡潔に仮定を明記してから続行してください。事実ベースで一次情報を最優先し、本文にMarkdownリンクで出典を埋め込んでください。\n---\nテーマ: ${theme}\nターゲット: ${target}\n現在日付: ${today}`;
          const messages = [];
          for await (const msg of query({
            prompt: userPrompt,
            options: {
              customSystemPrompt: sys,
              allowedTools: ['WebSearch','WebFetch'],
              permissionMode: 'acceptEdits',
            },
          })) { messages.push(msg); }
          const assistantTexts = messages.filter(m=>m.type==='assistant').map(m=>{
            const c=m.message?.content; if(Array.isArray(c)){return c.filter(b=>b?.type==='text').map(b=>b.text).join('\n');} return '';
          }).filter(Boolean).join('\n\n');
          fs.writeFileSync(`${artifactsDir}/research.md`, assistantTexts || '');
          try { fs.writeFileSync(`${artifactsDir}/research_trace.json`, JSON.stringify(messages, null, 2)); } catch {}
          EOF
          node research.mjs

      - name: Collect research
        id: collect
        run: |
          b64=$(base64 -w 0 .note-artifacts/research.md 2>/dev/null || base64 .note-artifacts/research.md)
          echo "research_b64<<EOF" >> $GITHUB_OUTPUT
          echo "$b64" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload research artifacts
        uses: actions/upload-artifact@v4
        with:
          name: research-artifacts
          path: |
            .note-artifacts/research.md
            .note-artifacts/research_trace.json

  write:
    name: Write (Claude Sonnet 4.0)
    needs: research
    runs-on: ubuntu-latest
    env:
      ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
      THEME: ${{ github.event.inputs.theme }}
      TARGET: ${{ github.event.inputs.target }}
      MESSAGE: ${{ github.event.inputs.message }}
      CTA: ${{ github.event.inputs.cta }}
      INPUT_TAGS: ${{ github.event.inputs.tags }}
    outputs:
      title: ${{ steps.collect.outputs.title }}
      draft_json_b64: ${{ steps.collect.outputs.draft_json_b64 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install AI SDK
        run: |
          npm init -y
          npm i ai @ai-sdk/anthropic

      - name: Restore research
        env:
          RESEARCH_B64: ${{ needs.research.outputs.research_b64 }}
        run: |
          mkdir -p .note-artifacts
          echo "$RESEARCH_B64" | base64 -d > .note-artifacts/research.md || echo "$RESEARCH_B64" | base64 --decode > .note-artifacts/research.md

      - name: Generate draft (title/body/tags)
        run: |
          cat > write.mjs <<'EOF'
          import { generateText } from 'ai';
          import { anthropic } from '@ai-sdk/anthropic';
          import fs from 'fs';
          
          console.log('🚀 記事生成開始...');
          
          const theme=process.env.THEME||''; 
          const target=process.env.TARGET||''; 
          const message=process.env.MESSAGE||''; 
          const cta=process.env.CTA||'';
          const inputTags=(process.env.INPUT_TAGS||'').split(',').map(s=>s.trim()).filter(Boolean);
          
          console.log(`📋 入力パラメータ:`);
          console.log(`  テーマ: ${theme}`);
          console.log(`  ターゲット: ${target}`);
          console.log(`  メッセージ: ${message}`);
          console.log(`  CTA: ${cta}`);
          console.log(`  タグ: ${inputTags.join(', ')}`);
          
          let researchReport = '';
          try {
            researchReport = fs.readFileSync('.note-artifacts/research.md','utf8');
            console.log(`✅ リサーチデータ読み込み完了: ${researchReport.length}文字`);
          } catch (error) {
            console.log(`⚠️ リサーチデータ読み込み失敗: ${error.message}`);
            researchReport = `${theme}に関する基本的な情報をまとめた記事です。`;
          }
          
          const modelName='claude-3-5-sonnet-20241022';
          
          function extractJsonFlexible(raw) {
            const t = (raw || '').trim().replace(/\u200B/g, '');
            try { return JSON.parse(t); } catch {}
            const m = t.match(/```[a-zA-Z]*\s*([\s\S]*?)\s*```/);
            if (m && m[1]) {
              try { return JSON.parse(m[1].trim()); } catch {}
            }
            const f = t.indexOf('{'), l = t.lastIndexOf('}');
            if (f !== -1 && l !== -1 && l > f) {
              const c = t.slice(f, l + 1);
              try { return JSON.parse(c); } catch {}
            }
            return null;
          }
          
          function sanitizeTitle(t) {
            let s = String(t || '').trim();
            s = s.replace(/^```[a-zA-Z0-9_-]*\s*$/, '').replace(/^```$/, '');
            s = s.replace(/^#+\s*/, '');
            s = s.replace(/^"+|"+$/g, '').replace(/^'+|'+$/g, '');
            s = s.replace(/^`+|`+$/g, '');
            s = s.replace(/^json$/i, '').trim();
            if (!s) s = 'タイトル（自動生成）';
            return s;
          }
          
          const sysWrite = `
          あなたはnote.com向けの記事ライターです。以下の指示に従って記事を作成してください：
          
          1. 出力は必ずJSON形式で返してください: {"title": "記事タイトル", "draftBody": "記事本文", "tags": ["タグ1", "タグ2"]}
          2. draftBodyは4000文字以上の読み応えのある内容にしてください
          3. 見出し（##）と箇条書きを適切に使用してください
          4. 読者にとって価値のある具体的な情報を含めてください
          5. 記事の最後に行動を促すCTAを含めてください
          `;
          
          const prompt = `
          以下の条件で記事を作成してください：
          
          【テーマ】: ${theme}
          【ターゲット読者】: ${target}
          【伝えたいメッセージ】: ${message}
          【読後のアクション】: ${cta}
          【リサーチ内容】: ${researchReport.substring(0, 3000)}
          
          上記を踏まえて、魅力的で実用的な記事をJSON形式で作成してください。
          `;
          
          console.log('🤖 AI記事生成中...');
          
          try {
            const { text } = await generateText({
              model: anthropic(modelName),
              system: sysWrite,
              prompt: prompt,
              temperature: 0.7,
              maxTokens: 30000
            });
            
            console.log('✅ AI応答受信完了');
            console.log(`📋 応答内容プレビュー: ${text.substring(0, 200)}...`);
            
            let obj = extractJsonFlexible(text || '');
            let title, draftBody, tags;
            
            if (obj && obj.title && obj.draftBody) {
              title = sanitizeTitle(obj.title);
              draftBody = String(obj.draftBody || '').trim();
              tags = Array.isArray(obj.tags) ? obj.tags.map(String) : [];
              console.log('✅ JSON解析成功');
            } else {
              console.log('⚠️ JSON解析失敗、フォールバック処理実行');
              // フォールバック処理
              const lines = (text || '').split(/\r?\n/);
              title = sanitizeTitle(lines.find(line => line.trim() && !line.startsWith('```')) || theme);
              draftBody = text || `${theme}について\n\n${message}\n\n詳細な内容については、さらなる調査が必要です。`;
              tags = [];
            }
            
            // 入力タグを追加
            if (inputTags.length) {
              tags = Array.from(new Set([...(tags || []), ...inputTags]));
            }
            
            const finalData = { title, draftBody, tags };
            
            console.log('📋 最終記事データ:');
            console.log(`  タイトル: ${title}`);
            console.log(`  本文長: ${draftBody.length}文字`);
            console.log(`  タグ: ${tags.join(', ')}`);
            
            // ファイル保存
            fs.writeFileSync('.note-artifacts/draft.json', JSON.stringify(finalData, null, 2));
            console.log('✅ draft.json保存完了');
            
            // ファイル確認
            const savedFile = fs.readFileSync('.note-artifacts/draft.json', 'utf8');
            console.log(`📋 保存確認: ${savedFile.length}文字のファイルが作成されました`);
            
          } catch (error) {
            console.error('❌ 記事生成エラー:', error.message);
            
            // エラー時のフォールバック
            const fallbackData = {
              title: theme || 'AI生成記事',
              draftBody: `# ${theme || 'AI生成記事'}\n\n${message || 'この記事は自動生成されました。'}\n\n## 概要\n\n${target || '読者の皆様'}に向けて、${theme || 'テーマ'}について説明します。\n\n## まとめ\n\n${cta || '詳細については、さらなる調査をお勧めします。'}`,
              tags: inputTags.length ? inputTags : ['AI', '自動生成']
            };
            
            fs.writeFileSync('.note-artifacts/draft.json', JSON.stringify(fallbackData, null, 2));
            console.log('✅ フォールバック記事を保存しました');
          }
          EOF
          node write.mjs

      - name: Collect draft
        id: collect
        run: |
          # ファイル存在確認
          if [ ! -f .note-artifacts/draft.json ]; then
            echo "❌ draft.jsonが生成されていません"
            exit 1
          fi
          
          echo "✅ draft.json確認完了"
          ls -la .note-artifacts/draft.json
          
          title=$(node -e "console.log(JSON.parse(require('fs').readFileSync('.note-artifacts/draft.json','utf8')).title)")
          b64=$(base64 -w 0 .note-artifacts/draft.json 2>/dev/null || base64 .note-artifacts/draft.json)
          echo "title<<EOF" >> $GITHUB_OUTPUT
          echo "$title" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "draft_json_b64<<EOF" >> $GITHUB_OUTPUT
          echo "$b64" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload draft artifact
        uses: actions/upload-artifact@v4
        with:
          name: draft-artifact
          path: .note-artifacts/draft.json

  post:
    name: Post to note.com (Playwright)
    needs: write
    if: ${{ github.event.inputs.dry_run != 'true' }}
    runs-on: ubuntu-latest
    env:
      IS_PUBLIC: ${{ github.event.inputs.is_public }}
      STATE_JSON: ${{ secrets.NOTE_STORAGE_STATE_JSON }}
      START_URL: https://editor.note.com/new
    outputs:
      final_url: ${{ steps.publish.outputs.published_url || steps.publish.outputs.draft_url }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Playwright
        run: |
          npm init -y
          npm i playwright
          npx playwright install --with-deps chromium | cat

      - name: Prepare storageState
        id: state
        run: |
          test -n "$STATE_JSON" || (echo "ERROR: NOTE_STORAGE_STATE_JSON secret is not set" && exit 1)
          mkdir -p "$RUNNER_TEMP"
          echo "$STATE_JSON" > "$RUNNER_TEMP/note-state.json"
          echo "STATE_PATH=$RUNNER_TEMP/note-state.json" >> $GITHUB_OUTPUT

      - name: Ensure jq (post)
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

      - name: Restore draft
        id: draft
        env:
          DRAFT_B64: ${{ needs.write.outputs.draft_json_b64 }}
        run: |
          test -n "$DRAFT_B64" || { echo "draft_json_b64 output is empty"; exit 1; }
          mkdir -p .note-artifacts
          echo "$DRAFT_B64" | base64 -d > .note-artifacts/draft.json || echo "$DRAFT_B64" | base64 --decode > .note-artifacts/draft.json
          cp .note-artifacts/draft.json draft.json
          echo "TITLE=$(jq -r .title draft.json)" >> $GITHUB_OUTPUT
          echo "TAGS=$(jq -r '.tags | join(", ")' draft.json)" >> $GITHUB_OUTPUT

      - name: Publish via Playwright (draft or public)
        id: publish
        env:
          TITLE: ${{ steps.draft.outputs.TITLE }}
          TAGS: ${{ steps.draft.outputs.TAGS }}
          STATE_PATH: ${{ steps.state.outputs.STATE_PATH }}
        run: |
          cat > post.mjs <<'EOF'
          import { chromium } from 'playwright';
          import fs from 'fs';
          import os from 'os';
          import path from 'path';

          function nowStr(){ 
            const d=new Date(); 
            const z=n=>String(n).padStart(2,'0'); 
            return `${d.getFullYear()}-${z(d.getMonth()+1)}-${z(d.getDate())}_${z(d.getHours())}-${z(d.getMinutes())}-${z(d.getSeconds())}`; 
          }

          const STATE_PATH=process.env.STATE_PATH;
          const START_URL=process.env.START_URL||'https://editor.note.com/new';
          const rawTitle=process.env.TITLE||'';
          const TAGS=process.env.TAGS||'';
          const IS_PUBLIC=String(process.env.IS_PUBLIC||'false')==='true';

          // draft.jsonを読み込み
          let articleData;
          try {
            if (fs.existsSync('draft.json')) {
              articleData = JSON.parse(fs.readFileSync('draft.json','utf8'));
              console.log('✅ draft.jsonから記事データを読み込み完了');
            } else {
              console.error('❌ draft.json が見つかりません');
              console.log('📋 現在のディレクトリ内容:');
              const files = fs.readdirSync('.');
              files.forEach(file => console.log(`  - ${file}`));
              process.exit(1);
            }
          } catch (error) {
            console.error('❌ draft.json読み込みエラー:', error.message);
            process.exit(1);
          }

          const rawBody = String(articleData.draftBody || articleData.body || '');

          function sanitizeTitle(t){
            let s=String(t||'').trim();
            s=s.replace(/^```[a-zA-Z0-9_-]*\s*$/,'').replace(/^```$/,'');
            s=s.replace(/^#+\s*/,'');
            s=s.replace(/^"+|"+$/g,'').replace(/^'+|'+$/g,'');
            s=s.replace(/^`+|`+$/g,'');
            s=s.replace(/^json$/i,'').trim();
            if (/^[\{\}\[\]\(\)\s]*$/.test(s)) s='';
            if(!s) s='タイトル（自動生成）';
            return s;
          }

          function processTextContent(text) {
            return String(text||'')
              .replace(/\*\*(.*?)\*\*/g, '$1')
              .replace(/\*(.*?)\*/g, '$1')
              .replace(/`(.*?)`/g, '$1')
              .replace(/#{1,6}\s+/g, '')
              .replace(/^\s*[-*+]\s+/gm, '• ')
              .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
              .trim();
          }

          let TITLE = sanitizeTitle(rawTitle || articleData.title || '');
          let processedBody = processTextContent(rawBody);

          if(!TITLE || TITLE==='タイトル（自動生成）'){
            const lines = processedBody.split('\n');
            for(const line of lines) {
              const clean = line.trim();
              if(clean && clean.length > 0) {
                TITLE = sanitizeTitle(clean);
                break;
              }
            }
          }

          console.log(`🔍 記事情報:`);
          console.log(`  - タイトル: "${TITLE}"`);
          console.log(`  - 本文: ${processedBody.length}文字`);
          console.log(`  - タグ: ${TAGS || 'なし'}`);
          console.log(`  - 公開設定: ${IS_PUBLIC ? '公開' : '下書き'}`);

          if(!fs.existsSync(STATE_PATH)){ 
            console.error('❌ storageState not found:', STATE_PATH); 
            console.log('💡 NOTE_STORAGE_STATE_JSON シークレットが正しく設定されているか確認してください');
            process.exit(1); 
          }

          const ssDir=path.join(os.tmpdir(),'note-screenshots'); 
          fs.mkdirSync(ssDir,{recursive:true}); 

          let browser, context, page;
          try{
            browser = await chromium.launch({ headless: true, args: ['--lang=ja-JP'] });
            context = await browser.newContext({ storageState: STATE_PATH, locale: 'ja-JP' });
            page = await context.newPage();
            page.setDefaultTimeout(180000);

            // デバッグ用ネットワーク監視
            page.on('response', response => {
              if (response.url().includes('/api/')) {
                console.log(`🔍 API Response: ${response.status()} ${response.url()}`);
              }
            });

            await page.goto(START_URL, { waitUntil: 'domcontentloaded' });
            console.log(`🔍 ページ読み込み完了: ${page.url()}`);

            // タイトル入力要素を探索
            const titleSelectors = [
              'textarea[placeholder*="タイトル"]',
              'input[placeholder*="タイトル"]', 
              'textarea[data-testid*="title"]',
              'input[data-testid*="title"]',
              '[contenteditable][data-placeholder*="タイトル"]'
            ];
            
            let titleElement = null;
            for (const selector of titleSelectors) {
              try {
                await page.waitForSelector(selector, { timeout: 5000 });
                titleElement = page.locator(selector).first();
                console.log(`🔍 タイトル要素発見: ${selector}`);
                break;
              } catch {
                console.log(`🔍 タイトル要素なし: ${selector}`);
              }
            }
            
            if (!titleElement) {
              console.log(`🔍 エラー: タイトル入力要素が見つからない`);
              await page.screenshot({ path: `${ssDir}/error-no-title-${nowStr()}.png`, fullPage: true });
              process.exit(1);
            }

            // デバッグ用スクリーンショット
            await page.screenshot({ path: `${ssDir}/debug-1-initial-${nowStr()}.png`, fullPage: true });

            // タイトル入力
            await titleElement.fill(TITLE);
            console.log(`🔍 タイトル入力完了`);
            await page.screenshot({ path: `${ssDir}/debug-2-after-title-${nowStr()}.png`, fullPage: true });

            // 本文入力要素を探索
            const bodySelectors = [
              'div[contenteditable="true"][role="textbox"]',
              'div[contenteditable="true"][data-testid*="editor"]', 
              'div[contenteditable="true"]',
              'textarea[data-testid*="body"]',
              'textarea[placeholder*="本文"]'
            ];
            
            let bodyElement = null;
            for (const selector of bodySelectors) {
              const count = await page.locator(selector).count();
              if (count > 0) {
                bodyElement = page.locator(selector).first();
                console.log(`🔍 本文要素発見: ${selector} (${count}個)`);
                break;
              }
            }
            
            if (!bodyElement) {
              console.log(`🔍 エラー: 本文入力要素が見つからない`);
              await page.screenshot({ path: `${ssDir}/error-no-body-${nowStr()}.png`, fullPage: true });
              process.exit(1);
            }

            // 本文入力（シンプルなテキスト入力）
            await bodyElement.waitFor({ state: 'visible' });
            await bodyElement.click();
            await page.keyboard.type(processedBody, { delay: 10 });
            console.log(`🔍 本文入力完了`);
            await page.screenshot({ path: `${ssDir}/debug-3-after-body-${nowStr()}.png`, fullPage: true });

            if(!IS_PUBLIC){
              // 下書き保存ボタンを探索
              const saveSelectors = [
                'button:has-text("下書き保存")',
                'button:has-text("下書きに保存")',
                'button:has-text("保存")',
                '[aria-label*="下書き保存"]',
                '[aria-label*="保存"]',
                'button[data-testid*="draft"]',
                'button[data-testid*="save"]',
                '[role="button"]:has-text("下書き")',
                '[role="button"]:has-text("保存")'
              ];
              
              await page.screenshot({ path: `${ssDir}/debug-4-searching-save-${nowStr()}.png`, fullPage: true });
              
              let saveButton = null;
              console.log(`🔍 下書き保存ボタンを探索中...`);
              
              for (const selector of saveSelectors) {
                const count = await page.locator(selector).count();
                console.log(`🔍 "${selector}": ${count}個`);
                if (count > 0) {
                  saveButton = page.locator(selector).first();
                  const text = await saveButton.textContent();
                  console.log(`🔍 発見！ボタンテキスト: "${text}"`);
                  break;
                }
              }
              
              // 全ボタンを表示（デバッグ用）
              const allButtons = await page.locator('button').all();
              console.log(`🔍 全ボタン (${allButtons.length}個)：`);
              for (let i = 0; i < Math.min(10, allButtons.length); i++) {
                const text = await allButtons[i].textContent();
                const ariaLabel = await allButtons[i].getAttribute('aria-label');
                console.log(`  ${i+1}. "${text}" [${ariaLabel}]`);
              }
              
              if (!saveButton) {
                console.log(`🔍 エラー: 下書き保存ボタンが見つからない`);
                await page.screenshot({ path: `${ssDir}/error-no-save-button-${nowStr()}.png`, fullPage: true });
                process.exit(1);
              }
              
              try {
                await saveButton.waitFor({ state: 'visible', timeout: 10000 });
                const isVisible = await saveButton.isVisible();
                const isEnabled = await saveButton.isEnabled();
                console.log(`🔍 下書き保存ボタン状態: 表示=${isVisible}, 有効=${isEnabled}`);
                
                if(isVisible && isEnabled) { 
                  console.log(`🔍 下書き保存ボタンをクリック`);
                  await saveButton.click(); 
                  await page.screenshot({ path: `${ssDir}/debug-5-after-save-${nowStr()}.png`, fullPage: true });
                  
                  // 保存完了待機
                  await page.waitForTimeout(3000);
                  console.log(`🔍 保存処理完了`);
                } else {
                  console.log(`🔍 エラー: 下書き保存ボタンが使用不可`);
                }
              } catch (error) {
                console.log(`🔍 エラー: 保存処理中に問題発生 - ${error.message}`);
              }
              
              await page.screenshot({ path: `${ssDir}/debug-6-final-${nowStr()}.png`, fullPage: true });
              console.log(`🔍 最終URL: ${page.url()}`);
              console.log('DRAFT_URL=' + page.url());
              process.exit(0);
            }

            // 公開処理（省略）

          } finally {
            try{ await page?.close(); }catch{}
            try{ await context?.close(); }catch{}
            try{ await browser?.close(); }catch{}
          }
          EOF
          node post.mjs | tee post.log
          url=$(grep '^PUBLISHED_URL=' post.log | tail -n1 | cut -d'=' -f2-)
          draft=$(grep '^DRAFT_URL=' post.log | tail -n1 | cut -d'=' -f2-)
          shot=$(grep '^SCREENSHOT=' post.log | tail -n1 | cut -d'=' -f2-)
          if [ -n "$url" ]; then echo "published_url=$url" >> $GITHUB_OUTPUT; fi
          if [ -n "$draft" ]; then echo "draft_url=$draft" >> $GITHUB_OUTPUT; fi
          if [ -n "$shot" ]; then echo "screenshot=$shot" >> $GITHUB_OUTPUT; fi

      - name: Upload screenshot (if any)
        if: ${{ steps.publish.outputs.screenshot != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: note-screenshot
          path: ${{ steps.publish.outputs.screenshot }}
